import 'styles/index.scss';

export default class App {
  init() {
    this.backgroundColor = 0x333333;
    this.ambientLightColor = 0xffffff;
    this.spotLightColor = 0xffffff;
    this.angle = 0;
    this.gridSize = 1;
    this.spheres = [];
    this.holes = [];
    this.gui = new dat.GUI();

    this.velocity = .1;
    this.amplitude = -1;
    this.frequency = 0;
    this.waveLength = 7;

    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(this.backgroundColor);

    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100);
    this.camera.position.set(10.7, 10.3, -10.9);

    this.addRenderer();

    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    // this.controls.minDistance = 0;
    // this.controls.maxDistance = 500;

    // this.addAmbientLight();

    // this.addHemisphereLight();

    // this.addSpotLight();

    // // this.addFloorShadow();

    // this.addPointLight();

    this.addGrid();

    this.floorShape = this.createShape();

    // this.createRingOfHoles(this.floorShape, 1, 0);

    // this.createRingOfHoles(this.floorShape, 5, .5);

    // this.createRingOfHoles(this.floorShape, 10, 1);

    // this.createRingOfHoles(this.floorShape, 20, 1.5);

    // this.createRingOfHoles(this.floorShape, 30, 2);

    // this.createRingOfHoles(this.floorShape, 40, 2.5);

    // this.createRingOfHoles(this.floorShape, 50, 3);

    // this.createRingOfHoles(this.floorShape, 60, 3.5);

    // this.createRingOfHoles(this.floorShape, 70, 4);

    // this.createRingOfHoles(this.floorShape, 80, 4.5);

    // this.createGround(this.floorShape);

    //this.addSpheres(this.scene);

    this.addBox();

    this.animate();

    window.addEventListener('resize', this.onResize.bind(this));
  }

  addBox() {
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('img/norm.jpg');

    const obj = {
      color: 0xffffff,
      emissive: 0x0,
      roughness: 0,
      metalness: 0,
      reflectivity: 0,
      envMap: texture
    };

    const topMaterial = new THREE.MeshPhongMaterial({
      map: texture,
      bumpMap: texture,
      bumpScale: 1,
      color: 0xf,
      specular: 0x0,
      reflectivity: 1,
      shininess: 1,
      envMap: texture
    });

    topMaterial.receiveShadow = true;
    // topMaterial.needsUpdate = true;

    const geometry = new THREE.BoxGeometry(1, 1, 1);

    const cube = new THREE.Mesh(geometry, topMaterial);
    this.scene.add(cube);
  }

  addHemisphereLight() {
    const obj = {
      skyColor: '#00ff00',
      groundColor: '#000',
      intensity: 1
    };

    this.hemisphereLight = new THREE.HemisphereLight(obj.skyColor, obj.groundColor, obj.intensity);

    this.scene.add(this.hemisphereLight);

    const gui = this.gui.addFolder('HemisphereLight');

    gui.add(obj, 'intensity', 0, 1).onChange((intensity) => {
      this.hemisphereLight.intensity = intensity;
    });

    gui.addColor(obj, 'skyColor').onChange((color) => {
      this.hemisphereLight.color = this.hexToRgbTreeJs(color);
    });

    gui.addColor(obj, 'groundColor').onChange((color) => {
      this.hemisphereLight.groundColor = this.hexToRgbTreeJs(color);
    });
  }

  radians(degrees) {
    return degrees * Math.PI / 180;
  }

  createShape() {
    const size = 10;
    const vectors = [
      new THREE.Vector2(-size, size),
      new THREE.Vector2(-size, -size),
      new THREE.Vector2(size, -size),
      new THREE.Vector2(size, size)
    ];

    const shape = new THREE.Shape(vectors);

    shape.autoClose = true;

    return shape;
  }

  createHoles(shape, x, z) {
    const radius = .5;
    const holePath = new THREE.Path();

    holePath.moveTo(x, z);
    holePath.ellipse(x, z, radius, radius, 0, Math.PI * 2);

    holePath.autoClose = true;

    shape.holes.push(holePath);

    this.holes.push({
      x,
      z
    })

  }

  addPointLight() {
    const obj = {
      color: '#ffffff',
      intensity: 1,
      distance: 0,
    };

    const light = new THREE.PointLight(obj.color, obj.intensity, obj.distance);

    light.position.set(0, 20, 0);

    var sphereSize = .1;
    var pointLightHelper = new THREE.PointLightHelper(light, sphereSize);
    this.scene.add(pointLightHelper);

    const gui = this.gui.addFolder('PointLight');

    gui.addColor(obj, 'color').onChange((color) => {
      light.color = this.hexToRgbTreeJs(color);
    });
    gui.add(obj, 'intensity', 0, 1).onChange((intensity) => {
      light.intensity = intensity;
    });

    gui.add(obj, 'distance', 0, 1).onChange((distance) => {
      light.distance = distance;
    });
    this.scene.add(light);
  }

  createGround(shape) {
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('img/norm.jpg');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);

    const obj = {
      color: '#000000',
      emissive: '#000000',
      roughness: 0,
      metalness: 0,
      reflectivity: 0,
      map: texture
    };

    const topMaterial = new THREE.MeshPhysicalMaterial({ obj });
    topMaterial.needsUpdate = true;

    const insideMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff
    });

    const gui = this.gui.addFolder('Floor Top - MeshPhysicalMaterial');

    gui.addColor(obj, 'color').onChange((color) => {
      topMaterial.needsUpdate = true;
      topMaterial.color = this.hexToRgbTreeJs(color);
    });

    gui.addColor(obj, 'emissive').onChange((emissive) => {
      topMaterial.needsUpdate = true;
      topMaterial.emissive = this.hexToRgbTreeJs(emissive);
    });

    gui.add(obj, 'roughness', 0, 1).onChange((color) => {
      topMaterial.needsUpdate = true;
      topMaterial.emissive = this.hexToRgbTreeJs(color);
    });

    gui.add(obj, 'metalness', 0, 1).onChange((metalness) => {
      topMaterial.needsUpdate = true;
      topMaterial.metalness = metalness;
    });

    gui.add(obj, 'reflectivity', 0, 1).onChange((reflectivity) => {
      topMaterial.needsUpdate = true;
      topMaterial.reflectivity = reflectivity;
    });

    const materials = [topMaterial, insideMaterial];
    const props = {
      steps: 1,
      amount: 1,
      bevelEnabled: false
    };
    const geometry = new THREE.ExtrudeGeometry(
      shape,
      props
    );

    const mesh = new THREE.Mesh(geometry, materials);

    mesh.rotation.set(Math.PI * 0.5, 0, 0);
    this.scene.add(mesh);
  }

  createRingOfHoles(shape, count, radius) {
    const l = 360 / count;
    const distance = (radius * 2);

    for (let index = 0; index < count; index++) {
      const pos = this.radians(l * index);
      const sin = Math.sin(pos) * distance;
      const cos = Math.cos(pos) * distance;

      this.createHoles(shape, sin, cos);
    }
  }

  addRenderer() {
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.setSize(window.innerWidth, window.innerHeight);

    document.body.appendChild(this.renderer.domElement);
  }

  addAmbientLight() {
    const obj = {
      color: '#ffffff'
    };
    const light = new THREE.AmbientLight(obj.color, 1);
    this.scene.add(light);
    const gui = this.gui.addFolder('addAmbientLight');

    gui.addColor(obj, 'color').onChange((color) => {
      light.color = this.hexToRgbTreeJs(color);
    });
  }

  addSpotLight() {
    this.spotLight = new THREE.SpotLight(this.spotLightColor);
    this.spotLight.position.set(0, 100, 0);
    this.spotLight.castShadow = true;
    this.scene.add(this.spotLight);
  }

  addSpheres(scene) {
    const total = this.holes.length;

    for (let i = 0; i < total; i++) {
      const sphere = this.getSphere();

      this.spheres[i] = sphere;

      sphere.position.set(this.holes[i].x * 2, 1, this.holes[i].z * 2);

      scene.add(sphere);
    }
  }

  hexToRgbTreeJs(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16) / 255,
      g: parseInt(result[2], 16) / 255,
      b: parseInt(result[3], 16) / 255
    } : null;
  }

  getSphere() {
    const radius = .5;
    const widthSegments = 32;
    const heightSegments = 32;
    const phiStart = 0;
    const phiLength = 6.3
    const thetaStart = 0;
    const thetaLength = 6.3;

    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('img/norm.jpg');

    const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
    const material = new THREE.MeshPhysicalMaterial({
      color: 0xce2121,
      emissive: 0x760090,
      metalness: 0,
      roughness: 0,
      clearCoat: 0,
      clearCoatRoughness: 0,
      reflectivity: 1,
      map: texture,
    });

    material.needsUpdate = true;

    const mesh = new THREE.Mesh(geometry, material);

    mesh.castShadow = true;
    mesh.receiveShadow = true;

    return mesh;
  }

  drawWave() {
    const total = this.holes.length;
    const l = 360 / total;

    for (let i = 0; i < total; i++) {
      const pos = this.radians(l * i);
      const sin = Math.sin(pos);
      const cos = Math.cos(pos);

      const distance = this.distance(cos, sin, 10, 10);
      const offset = this.map(distance, -2, this.waveLength, -1, 1);

      const angle = this.angle + offset;

      const y = this.map(Math.sin(angle), -10, -this.amplitude, -5, 5);

      this.spheres[i].position.y = y;
    }

    this.angle -= this.velocity;
  }

  distance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
  }

  map(value, start1, stop1, start2, stop2) {
    return (value - start1) / (stop1 - start1) * (stop2 - start2) + start2
  }

  addFloorShadow() {
    const planeGeometry = new THREE.PlaneGeometry(500, 500);
    const planeMaterial = new THREE.ShadowMaterial({ opacity: 1 });

    this.floor = new THREE.Mesh(planeGeometry, planeMaterial);

    planeGeometry.rotateX(- Math.PI / 2);

    this.floor.position.y = 0;
    this.floor.receiveShadow = true;

    this.scene.add(this.floor);
  }


  addGrid() {
    const size = 24;
    const divisions = size;
    const gridHelper = new THREE.GridHelper(size, divisions);

    gridHelper.position.set(0, 0, 0);
    gridHelper.material.opacity = 0;
    gridHelper.material.transparent = true;

    this.scene.add(gridHelper);
  }

  animate() {
    // this.drawWave();

    this.controls.update();

    this.renderer.render(this.scene, this.camera);

    requestAnimationFrame(this.animate.bind(this));
  }

  onResize() {
    const ww = window.innerWidth;
    const wh = window.innerHeight;

    this.camera.aspect = ww / wh;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(ww, wh);
  }
}
